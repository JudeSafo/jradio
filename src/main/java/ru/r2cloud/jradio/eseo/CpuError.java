package ru.r2cloud.jradio.eseo;

import java.io.IOException;

import ru.r2cloud.jradio.util.LittleEndianDataInputStream;

public class CpuError {

	private boolean hardFaultVECTTBL;// forced hard fault generated by escalation
	private boolean hardFaultFORCED;// hard fault during exception processing
	private boolean memManageIACCVIOL;// Instruction access violating flag
	private boolean memManageDACCVIOL;// data access violating flag
	private boolean memManageMSTKERR;// memory manager fault on unstacking for a return from exception
	private boolean memManageMUNKSERR;// memory manage fault on stacking for exception entry
	private boolean memManageMLSPERR;// fault occurred during floating point state preservation
	private boolean busErrorSTKERR;// bus fault on stacking for exception entry
	private boolean busErrorUNSTKERR;// bus fault on unstacking for a return on exception
	private boolean busErrorIBUSERR;// instruction bus error
	private boolean busErrorLSPERR;// nus fault on floating point lazy state preservation
	private boolean busErrorPRECISERR;// precise data bus error
	private boolean busErrorIMPRECISERR;// imprecise data bus error
	private boolean usageFaultNOCP;// no coprocessor usage fault
	private boolean usageFaultUNDEFINSTR;// undefined instruction usage fault
	private boolean usageFaultINVSTATE;// Invalid state usage fault
	private boolean usageFaultINVCP;// Invalid PC load usage fault
	private boolean usageFaultUNALIGNED;// unaligned access usage fault
	private boolean usageFaultDIVBYZERO;// division by zero fault

	public CpuError() {
		// do nothing
	}

	public CpuError(LittleEndianDataInputStream dis) throws IOException {
		int raw = dis.readUnsignedByte();
		hardFaultVECTTBL = ((raw >> 7) & 0x1) > 0;
		hardFaultFORCED = ((raw >> 6) & 0x1) > 0;
		memManageIACCVIOL = ((raw >> 5) & 0x1) > 0;
		memManageDACCVIOL = ((raw >> 4) & 0x1) > 0;
		memManageMSTKERR = ((raw >> 3) & 0x1) > 0;
		memManageMUNKSERR = ((raw >> 2) & 0x1) > 0;
		memManageMLSPERR = ((raw >> 1) & 0x1) > 0;
		busErrorSTKERR = (raw & 0x1) > 0;

		raw = dis.readUnsignedByte();
		busErrorUNSTKERR = ((raw >> 7) & 0x1) > 0;
		busErrorIBUSERR = ((raw >> 6) & 0x1) > 0;
		busErrorLSPERR = ((raw >> 5) & 0x1) > 0;
		busErrorPRECISERR = ((raw >> 4) & 0x1) > 0;
		busErrorIMPRECISERR = ((raw >> 3) & 0x1) > 0;
		usageFaultNOCP = ((raw >> 2) & 0x1) > 0;
		usageFaultUNDEFINSTR = ((raw >> 1) & 0x1) > 0;
		usageFaultINVSTATE = (raw & 0x1) > 0;

		raw = dis.readUnsignedByte();
		usageFaultINVCP = ((raw >> 7) & 0x1) > 0;
		usageFaultUNALIGNED = ((raw >> 6) & 0x1) > 0;
		usageFaultDIVBYZERO = ((raw >> 5) & 0x1) > 0;
		dis.skipBytes(1);
	}

	public boolean isHardFaultVECTTBL() {
		return hardFaultVECTTBL;
	}

	public void setHardFaultVECTTBL(boolean hardFaultVECTTBL) {
		this.hardFaultVECTTBL = hardFaultVECTTBL;
	}

	public boolean isHardFaultFORCED() {
		return hardFaultFORCED;
	}

	public void setHardFaultFORCED(boolean hardFaultFORCED) {
		this.hardFaultFORCED = hardFaultFORCED;
	}

	public boolean isMemManageIACCVIOL() {
		return memManageIACCVIOL;
	}

	public void setMemManageIACCVIOL(boolean memManageIACCVIOL) {
		this.memManageIACCVIOL = memManageIACCVIOL;
	}

	public boolean isMemManageDACCVIOL() {
		return memManageDACCVIOL;
	}

	public void setMemManageDACCVIOL(boolean memManageDACCVIOL) {
		this.memManageDACCVIOL = memManageDACCVIOL;
	}

	public boolean isMemManageMSTKERR() {
		return memManageMSTKERR;
	}

	public void setMemManageMSTKERR(boolean memManageMSTKERR) {
		this.memManageMSTKERR = memManageMSTKERR;
	}

	public boolean isMemManageMUNKSERR() {
		return memManageMUNKSERR;
	}

	public void setMemManageMUNKSERR(boolean memManageMUNKSERR) {
		this.memManageMUNKSERR = memManageMUNKSERR;
	}

	public boolean isMemManageMLSPERR() {
		return memManageMLSPERR;
	}

	public void setMemManageMLSPERR(boolean memManageMLSPERR) {
		this.memManageMLSPERR = memManageMLSPERR;
	}

	public boolean isBusErrorSTKERR() {
		return busErrorSTKERR;
	}

	public void setBusErrorSTKERR(boolean busErrorSTKERR) {
		this.busErrorSTKERR = busErrorSTKERR;
	}

	public boolean isBusErrorUNSTKERR() {
		return busErrorUNSTKERR;
	}

	public void setBusErrorUNSTKERR(boolean busErrorUNSTKERR) {
		this.busErrorUNSTKERR = busErrorUNSTKERR;
	}

	public boolean isBusErrorIBUSERR() {
		return busErrorIBUSERR;
	}

	public void setBusErrorIBUSERR(boolean busErrorIBUSERR) {
		this.busErrorIBUSERR = busErrorIBUSERR;
	}

	public boolean isBusErrorLSPERR() {
		return busErrorLSPERR;
	}

	public void setBusErrorLSPERR(boolean busErrorLSPERR) {
		this.busErrorLSPERR = busErrorLSPERR;
	}

	public boolean isBusErrorPRECISERR() {
		return busErrorPRECISERR;
	}

	public void setBusErrorPRECISERR(boolean busErrorPRECISERR) {
		this.busErrorPRECISERR = busErrorPRECISERR;
	}

	public boolean isBusErrorIMPRECISERR() {
		return busErrorIMPRECISERR;
	}

	public void setBusErrorIMPRECISERR(boolean busErrorIMPRECISERR) {
		this.busErrorIMPRECISERR = busErrorIMPRECISERR;
	}

	public boolean isUsageFaultNOCP() {
		return usageFaultNOCP;
	}

	public void setUsageFaultNOCP(boolean usageFaultNOCP) {
		this.usageFaultNOCP = usageFaultNOCP;
	}

	public boolean isUsageFaultUNDEFINSTR() {
		return usageFaultUNDEFINSTR;
	}

	public void setUsageFaultUNDEFINSTR(boolean usageFaultUNDEFINSTR) {
		this.usageFaultUNDEFINSTR = usageFaultUNDEFINSTR;
	}

	public boolean isUsageFaultINVSTATE() {
		return usageFaultINVSTATE;
	}

	public void setUsageFaultINVSTATE(boolean usageFaultINVSTATE) {
		this.usageFaultINVSTATE = usageFaultINVSTATE;
	}

	public boolean isUsageFaultINVCP() {
		return usageFaultINVCP;
	}

	public void setUsageFaultINVCP(boolean usageFaultINVCP) {
		this.usageFaultINVCP = usageFaultINVCP;
	}

	public boolean isUsageFaultUNALIGNED() {
		return usageFaultUNALIGNED;
	}

	public void setUsageFaultUNALIGNED(boolean usageFaultUNALIGNED) {
		this.usageFaultUNALIGNED = usageFaultUNALIGNED;
	}

	public boolean isUsageFaultDIVBYZERO() {
		return usageFaultDIVBYZERO;
	}

	public void setUsageFaultDIVBYZERO(boolean usageFaultDIVBYZERO) {
		this.usageFaultDIVBYZERO = usageFaultDIVBYZERO;
	}

}
